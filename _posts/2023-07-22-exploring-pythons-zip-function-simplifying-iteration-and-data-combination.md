---
layout: post
title: "Exploring Python’s zip() Function: Simplifying Iteration and Data Combination"
date: 2023-07-22 12:01:42 +0000
canonical_url: https://pub.towardsai.net/exploring-pythons-zip-function-simplifying-iteration-and-data-combination-df5e8412799?source=rss-8c8a65726e4c------2
link: https://pub.towardsai.net/exploring-pythons-zip-function-simplifying-iteration-and-data-combination-df5e8412799?source=rss-8c8a65726e4c------2
categories: [medium]
---

<h4>A Beginner’s Guide to Streamlining Data Manipulation and Iteration with zip() in Python for Enhanced Efficiency and Productivity</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*OwNOJRJT2vK119Fy" /><figcaption>Photo by <a href="https://unsplash.com/es/@tomas_nz">Tomas Sobek</a> on Unsplash</figcaption></figure><h3>Introduction</h3><p>Zip is an in-built function in the standard Python interpreter. It is a powerful method, that makes it easier to work with iterables such as dictionaries and lists.</p><p>In this article, we explore the syntax and working of the zip function, as we gain a practical understanding of how to utilize the method in real circumstances.</p><h3>Syntax</h3><p>The general function definition as per the Python documentation:</p><blockquote>zip(*iterables, strict=False)</blockquote><p>Given the definition, it is evident the method takes an arbitrary number of iterables using the *iterables non-keyword argument. Thus, we can pass any number of iterables to the zip function, which will be passed as a single list of argument.</p><p>There is a ‘strict’ keyword argument that we will explore later.</p><h3>Use Case Example 1</h3><p>To understand how to use the zip function, go over this interactive code snippet.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Freplit.com%2F%40MuhammadArham12%2FZipFunctionExample1%3Fembed%3Dtrue&amp;display_name=replit&amp;url=https%3A%2F%2Freplit.com%2F%40MuhammadArham12%2FZipFunctionExample1%3Fembed%3Dtrue&amp;image=https%3A%2F%2Freplit.com%2Fpublic%2Fimages%2Freplit-logo-800x600.png&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=replit" width="800" height="600" frameborder="0" scrolling="no"><a href="https://medium.com/media/7b90ef01848468921701e28356b45470/href">https://medium.com/media/7b90ef01848468921701e28356b45470/href</a></iframe><p>Consider we have 3 different lists. One contains the products, and the other two lists contain the quantity of products sold and its price.</p><p>If we want to calculate the the total sales for each product, we can do that using a simple for loop. However, we will have to index each array and will have to deal with edge cases in case of size mismatch. Moreover, the solution is not scalable for an arbitrary number of iterables.</p><p>The zip function provides a simple interface to perform such tasks, as you can pass all iterables to the zip function.</p><blockquote>This returns a iterator of tuples, where i-th tuple contains the i-th element from each of the argument iterables.</blockquote><p>So, for iterating over the zipped lists in the above example, each product will be combined with its price and quantity within a single tuple. This can be de-structured to obtain values during iteration.</p><p>Run the code above to better understand the working of zip function.</p><h3>Use Case Example 2</h3><p>This is a harder example. Suppose we have a 2-dimensional array, and we want to average over all values in the column.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Freplit.com%2F%40MuhammadArham12%2FZipFunctionExample2%3Fembed%3Dtrue&amp;display_name=replit&amp;url=https%3A%2F%2Freplit.com%2F%40MuhammadArham12%2FZipFunctionExample2%3Fembed%3Dtrue&amp;image=https%3A%2F%2Freplit.com%2Fpublic%2Fimages%2Freplit-logo-800x600.png&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=replit" width="800" height="600" frameborder="0" scrolling="no"><a href="https://medium.com/media/3de728d9c92e747c75c5734fc05fa800/href">https://medium.com/media/3de728d9c92e747c75c5734fc05fa800/href</a></iframe><p>Using for loop we can iterate rows of a matrix. For average of columns, we will have to use nested loops to iterate over columns separately.</p><p>Zip provides the a work around.</p><pre>transposed = zip(*matrix)</pre><p>We can transpose a matrix simply by passing all rows as iterables to the zip function. The * operator is used to unpack arguments, so it unpacks the matrix to transpose it.</p><pre>column_averages = [sum(column) / len(column) for column in transposed]</pre><p>We can then iterate over each column from the zipped iterable, to average the columns.</p><h3>How to Unzip Iterables</h3><p>Now that we have an understanding of both the zip and * operator, we can combine both to reverse the zip function.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Freplit.com%2F%40MuhammadArham12%2FHowToUnzip%3Fembed%3Dtrue&amp;display_name=replit&amp;url=https%3A%2F%2Freplit.com%2F%40MuhammadArham12%2FHowToUnzip%3Fembed%3Dtrue&amp;image=https%3A%2F%2Freplit.com%2Fpublic%2Fimages%2Freplit-logo-800x600.png&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=replit" width="800" height="600" frameborder="0" scrolling="no"><a href="https://medium.com/media/7e91f7b5d7beeec67aa2da1b53edc67e/href">https://medium.com/media/7e91f7b5d7beeec67aa2da1b53edc67e/href</a></iframe><p>Once we have zipped some iterables together, we can recover them by unpacking all the zipped tuples and then zipping them together.</p><p>Going over it step by step:</p><pre>products = [&#39;Apple&#39;, &#39;Banana&#39;, &#39;Cherry&#39;]<br>prices = [1.5, 0.75, 2.25]<br>quantities = [10, 15, 5]<br><br># Using zip() to combine the lists<br>sales = zip(products, prices, quantities)</pre><p>We first spread the iterables, that creates new iterables that is similar to the transpose matrix example above.</p><pre>print(*sales)<br># Output<br># (&#39;Apple&#39;, 1.5, 10) (&#39;Banana&#39;, 0.75, 15) (&#39;Cherry&#39;, 2.25, 5)</pre><p>We can now zip them together, such that all elements on first position are members of first iterable, all elements on second position are members of second iterable and so on.</p><blockquote>It’s important to note that once you iterate over a zip object, it is exhausted, meaning that the zip object becomes empty.</blockquote><p>Thus, we do this in a single-line short hand:</p><pre>products, prices, quantities = zip(*sales)</pre><h3>Strict Keyword Argument</h3><p>Zip function allows iterable of different sizes by default. If the iterables passed are of different sizes, only the elements up to the shortest iterable are zipped.</p><pre>list(zip(range(3), [&#39;fee&#39;, &#39;fi&#39;, &#39;fo&#39;, &#39;fum&#39;]))<br># Output [(0, &#39;fee&#39;), (1, &#39;fi&#39;), (2, &#39;fo&#39;)]</pre><p>However, mostly zip function is used for iterables of same sizes. To ensure this restriction, we can pass <strong>strict=True. </strong>This will raise a ValueError if there is a size match between iterable arguments.</p><h3>Benefits of Using Zip</h3><h4>Memory Efficient</h4><p>Zip is lazy. The iterables are generated on-the-fly during iteration. So a new list is not required to store the zipped iterables.</p><h4>Flexibility</h4><p>Zip works with a wide range of iterables such as lists, dictionaries, tuples and strings. It can even work with user-defined classes. All you have to do is implement the <strong>__iter__ </strong>dunder method in Python. A code example illustrates this.</p><pre>class Person:<br>    def __init__(self, name, age):<br>        self.name = name<br>        self.age = age<br>    <br>    def __iter__(self):<br>        return iter([self.name, self.age])<br><br># Create instances of the Person class<br>person1 = Person(&quot;John&quot;, 30)<br>person2 = Person(&quot;Alice&quot;, 25)<br>person3 = Person(&quot;Bob&quot;, 35)<br><br># Zip the Person objects<br>zipped = zip(person1, person2, person3)<br><br># Iterate over the zipped object and print the elements<br>for item in zipped:<br>    print(item)</pre><h3>Conclusion</h3><p>The zip function is versatile function that allows simultaneous iterations with simplified code structure. It can be combined with the map, filter and reduce function to achieve complex data manipulation using a few lines of code.</p><p>If you like this article, follow me for more articles on Python and Machine Learning domain.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=df5e8412799" width="1" height="1" alt=""><hr><p><a href="https://pub.towardsai.net/exploring-pythons-zip-function-simplifying-iteration-and-data-combination-df5e8412799">Exploring Python’s zip() Function: Simplifying Iteration and Data Combination</a> was originally published in <a href="https://pub.towardsai.net">Towards AI</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>